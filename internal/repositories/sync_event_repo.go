package repositories

import (
	"context"
	"errors"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/prudhvinik1/edgesync/internal/models"
)

type PostgresSyncEventRepository struct {
	pool *pgxpool.Pool
}

func NewPostgresSyncEventRepository(pool *pgxpool.Pool) *PostgresSyncEventRepository {
	return &PostgresSyncEventRepository{pool: pool}
}

// Append adds a new sync event to the event log.
// The sequence_number is auto-generated by the database (BIGSERIAL).
func (r *PostgresSyncEventRepository) Append(ctx context.Context, event *models.SyncEvent) error {
	query := `INSERT INTO sync_events (account_id, device_id, event_type, state_key, payload)
	          VALUES ($1, $2, $3, $4, $5)
	          RETURNING id, sequence_number, created_at`

	err := r.pool.QueryRow(ctx, query,
		event.AccountID,
		event.DeviceID,
		event.EventType,
		event.StateKey,
		event.Payload,
	).Scan(&event.ID, &event.SequenceNumber, &event.CreatedAt)

	if err != nil {
		return fmt.Errorf("failed to append sync event: %w", err)
	}
	return nil
}

func (r *PostgresSyncEventRepository) GetByID(ctx context.Context, id uuid.UUID) (*models.SyncEvent, error) {
	query := `SELECT id, account_id, device_id, event_type, state_key, sequence_number, payload, created_at
	          FROM sync_events 
	          WHERE id = $1`

	var event models.SyncEvent
	err := r.pool.QueryRow(ctx, query, id).Scan(
		&event.ID,
		&event.AccountID,
		&event.DeviceID,
		&event.EventType,
		&event.StateKey,
		&event.SequenceNumber,
		&event.Payload,
		&event.CreatedAt,
	)

	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get sync event: %w", err)
	}
	return &event, nil
}

func (r *PostgresSyncEventRepository) GetByAccountID(ctx context.Context, accountID uuid.UUID) ([]*models.SyncEvent, error) {
	query := `SELECT id, account_id, device_id, event_type, state_key, sequence_number, payload, created_at
	          FROM sync_events 
	          WHERE account_id = $1
	          ORDER BY sequence_number ASC`

	rows, err := r.pool.Query(ctx, query, accountID)
	if err != nil {
		return nil, fmt.Errorf("failed to query sync events: %w", err)
	}
	defer rows.Close()

	var events []*models.SyncEvent
	for rows.Next() {
		var event models.SyncEvent
		err := rows.Scan(
			&event.ID,
			&event.AccountID,
			&event.DeviceID,
			&event.EventType,
			&event.StateKey,
			&event.SequenceNumber,
			&event.Payload,
			&event.CreatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan sync event: %w", err)
		}
		events = append(events, &event)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating sync events: %w", err)
	}

	return events, nil
}

// GetSinceSequence returns all events for an account after the given sequence number.
// This is the key method for sync - clients say "give me everything since sequence X".
func (r *PostgresSyncEventRepository) GetSinceSequence(ctx context.Context, accountID uuid.UUID, sequenceNumber int64) ([]*models.SyncEvent, error) {
	query := `SELECT id, account_id, device_id, event_type, state_key, sequence_number, payload, created_at
	          FROM sync_events 
	          WHERE account_id = $1 AND sequence_number > $2
	          ORDER BY sequence_number ASC`

	rows, err := r.pool.Query(ctx, query, accountID, sequenceNumber)
	if err != nil {
		return nil, fmt.Errorf("failed to query sync events since sequence: %w", err)
	}
	defer rows.Close()

	var events []*models.SyncEvent
	for rows.Next() {
		var event models.SyncEvent
		err := rows.Scan(
			&event.ID,
			&event.AccountID,
			&event.DeviceID,
			&event.EventType,
			&event.StateKey,
			&event.SequenceNumber,
			&event.Payload,
			&event.CreatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan sync event: %w", err)
		}
		events = append(events, &event)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating sync events: %w", err)
	}

	return events, nil
}
